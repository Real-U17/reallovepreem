<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Real Block</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Mountains+of+Christmas:wght@400;700&family=Kanit:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #022c22;
            --grid-color: #064e3b;
            --accent-snow: #e0f2fe;
            --accent-red: #ef4444;
            --accent-gold: #f59e0b;
            --accent-tree: #22c55e;
        }

        body {
            font-family: 'Kanit', sans-serif;
            background-color: var(--bg-color);
            background-image: radial-gradient(circle at 50% 0%, #065f46 0%, #022c22 80%);
            color: #f0f9ff;
            overflow: hidden;
            touch-action: none;
        }

        .snowflake {
            position: absolute;
            color: #fff;
            font-size: 1em;
            font-family: Arial;
            text-shadow: 0 0 1px #000;
            top: -10%;
            z-index: 0;
            user-select: none;
            cursor: default;
            animation-name: snowflakes-fall, snowflakes-shake;
            animation-duration: 10s, 3s;
            animation-timing-function: linear, ease-in-out;
            animation-iteration-count: infinite, infinite;
            animation-play-state: running, running;
            opacity: 0.3;
        }
        @keyframes snowflakes-fall {
            0% { top: -10%; }
            100% { top: 100%; }
        }
        @keyframes snowflakes-shake {
            0% { transform: translateX(0px); }
            50% { transform: translateX(80px); }
            100% { transform: translateX(0px); }
        }
        .snowflake:nth-of-type(0) { left: 1%; animation-delay: 0s, 0s; }
        .snowflake:nth-of-type(1) { left: 10%; animation-delay: 1s, 1s; }
        .snowflake:nth-of-type(2) { left: 20%; animation-delay: 6s, .5s; }
        .snowflake:nth-of-type(3) { left: 30%; animation-delay: 4s, 2s; }
        .snowflake:nth-of-type(4) { left: 40%; animation-delay: 2s, 2s; }
        .snowflake:nth-of-type(5) { left: 50%; animation-delay: 8s, 3s; }
        .snowflake:nth-of-type(6) { left: 60%; animation-delay: 6s, 2s; }
        .snowflake:nth-of-type(7) { left: 70%; animation-delay: 2.5s, 1s; }
        .snowflake:nth-of-type(8) { left: 80%; animation-delay: 1s, 0s; }
        .snowflake:nth-of-type(9) { left: 90%; animation-delay: 3s, 1.5s; }


        .xmas-font {
            font-family: 'Mountains of Christmas', cursive;
            letter-spacing: 1px;
            font-weight: 700;
        }

        .back-button {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            color: #cbd5e1;
            text-decoration: none;
            font-weight: 600;
            font-size: 16px;
            padding: 8px 16px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 20px;
            backdrop-filter: blur(4px);
            transition: all 0.2s;
            z-index: 50;
        }
        .back-button:hover {
            background: rgba(255,255,255,0.25);
            color: white;
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(255,255,255,0.3);
        }

        .game-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 4px;
            padding: 6px;
            background: rgba(0, 0, 0, 0.2);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 16px;
            box-shadow: 0 0 25px rgba(220, 20, 60, 0.2);
            aspect-ratio: 1;
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
            position: relative;
            z-index: 10;
        }

        .cell {
            background: var(--grid-color);
            border-radius: 6px;
            transition: background-color 0.1s;
            position: relative;
        }

        .c-cyan { background-color: var(--accent-snow); box-shadow: 0 0 8px var(--accent-snow); }
        .c-pink { background-color: var(--accent-red); box-shadow: 0 0 8px var(--accent-red); }
        .c-yellow { background-color: var(--accent-gold); box-shadow: 0 0 8px var(--accent-gold); }
        .c-green { background-color: var(--accent-tree); box-shadow: 0 0 8px var(--accent-tree); }
        
        .cell.preview {
            opacity: 0.5;
            transform: scale(0.9);
            box-shadow: none;
            filter: brightness(1.2);
        }

        .shape-dock {
            display: flex;
            justify-content: space-around;
            align-items: center;
            min-height: 130px;
            margin-top: 15px;
            padding: 10px;
            width: 100%;
            background: rgba(255,255,255,0.05);
            border-radius: 20px;
            backdrop-filter: blur(5px);
            z-index: 10;
        }

        .draggable-shape {
            touch-action: none;
            cursor: grab;
            transition: transform 0.1s, opacity 0.2s;
            padding: 10px;
        }

        .draggable-shape:active {
            cursor: grabbing;
            transform: scale(1.1);
        }

        .mini-grid {
            display: grid;
            gap: 2px;
            pointer-events: none;
        }

        .mini-cell {
            width: 22px;
            height: 22px;
            border-radius: 4px;
            border: 1px solid rgba(0,0,0,0.1);
        }

        #drag-proxy {
            position: fixed;
            pointer-events: none;
            z-index: 100;
            display: none;
            opacity: 0.95;
            transform-origin: center center;
            filter: drop-shadow(0 5px 15px rgba(0,0,0,0.5));
        }

        #drag-proxy .mini-cell {
            width: 40px;
            height: 40px;
            gap: 4px;
        }
        
        #drag-proxy .mini-grid {
            gap: 4px;
        }

        @keyframes pop { 0% { transform: scale(0); } 70% { transform: scale(1.1); } 100% { transform: scale(1); } }
        @keyframes sparkle { 0% { filter: brightness(1); } 50% { filter: brightness(1.5); } 100% { filter: brightness(1); } }
        @keyframes clear-flash { 0% { transform: scale(1); background-color: #fff; } 100% { opacity: 0; transform: scale(1.2); } }

        .animate-pop { animation: pop 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); }
        .animate-clear { animation: clear-flash 0.4s forwards; z-index: 20; }

        .glass-panel {
            background: rgba(180, 20, 20, 0.2);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 215, 0, 0.2);
            border-radius: 16px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .ghost-active { opacity: 0.2; }

        .decor-icon {
            font-size: 24px;
            filter: drop-shadow(0 0 5px rgba(255,215,0,0.5));
        }
    </style>
</head>
<body class="h-screen w-full flex flex-col items-center justify-center p-4 select-none">

    <div class="snowflake">‚ùÖ</div>
    <div class="snowflake">‚ùÜ</div>
    <div class="snowflake">‚ùÖ</div>
    <div class="snowflake">‚ùÜ</div>
    <div class="snowflake">‚ùÜ</div>
    <div class="snowflake">‚ùÖ</div>
    <div class="snowflake">‚ùÜ</div>
    <div class="snowflake">‚ùÖ</div>
    <div class="snowflake">‚ùÜ</div>
    <div class="snowflake">‚ùÖ</div>

    <a href="index.html" class="back-button xmas-font">
        <span style="font-size: 20px;">üéÑ</span> MENU
    </a>

    <div class="w-full max-w-md flex justify-between items-end mb-4 mt-8 z-10">
        <div>
            <h1 class="text-5xl xmas-font text-transparent bg-clip-text bg-gradient-to-r from-red-400 via-yellow-200 to-green-400" style="text-shadow: 0 2px 10px rgba(239, 68, 68, 0.5);">REAL BLOCK</h1>
        </div>
        <div class="text-right">
            <div class="text-xs text-yellow-200 xmas-font tracking-widest">BEST GIFT</div>
            <div id="high-score" class="text-2xl font-bold text-yellow-400 xmas-font">0</div>
        </div>
    </div>

    <div class="glass-panel w-full max-w-md py-3 px-6 mb-4 flex justify-between items-center z-10">
        <span class="text-red-200 text-lg xmas-font">SCORE</span>
        <span id="current-score" class="text-4xl font-bold text-white xmas-font" style="text-shadow: 0 0 10px rgba(255,255,255,0.5);">0</span>
    </div>

    <div class="relative w-full max-w-md flex flex-col items-center">
        
        <div id="game-board" class="game-board"></div>

        <div id="shape-dock" class="shape-dock"></div>

    </div>

    <div id="drag-proxy"></div>

    <div id="game-over-modal" class="fixed inset-0 bg-black/80 z-50 flex items-center justify-center hidden opacity-0 transition-opacity duration-300 backdrop-blur-sm">
        <div class="text-center p-8 bg-[#0f2e1f] border-2 border-red-500 rounded-3xl shadow-[0_0_50px_rgba(239,68,68,0.4)]" id="modal-content">
            <div class="text-6xl mb-2">üéÖ</div>
            <h2 class="text-5xl xmas-font text-red-400 mb-2">OH NO!</h2>
            <p class="text-green-300 xmas-font text-xl mb-6">The bag is full!</p>
            <div class="text-4xl text-white xmas-font mb-8 drop-shadow-md" id="final-score">0</div>
            <button onclick="game.restart()" class="px-10 py-3 bg-gradient-to-r from-red-600 to-red-500 text-white font-bold text-2xl rounded-full hover:scale-105 hover:shadow-[0_0_20px_rgba(239,68,68,0.6)] transition-all xmas-font border border-red-400">
                TRY AGAIN üéÅ
            </button>
            <br><br>
            <a href="index.html" class="text-slate-400 hover:text-white underline text-sm mt-4">Return to Menu</a>
        </div>
    </div>

    <script>
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const now = audioCtx.currentTime;

            const createBell = (freq, duration, volume) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                
                osc.type = 'sine'; 
                osc.frequency.setValueAtTime(freq, now);
                
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(volume, now + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, now + duration);

                osc.connect(gain);
                gain.connect(audioCtx.destination);
                
                osc.start(now);
                osc.stop(now + duration);
            };

            if (type === 'pick') {
                createBell(880, 0.5, 0.1); 
                createBell(1760, 0.3, 0.05);
            } else if (type === 'place') {
                createBell(523.25, 1.0, 0.15);
                createBell(1046.50, 0.8, 0.05);
            } else if (type === 'clear') {
                createBell(523.25, 1.5, 0.1);
                setTimeout(() => createBell(659.25, 1.5, 0.1), 100);
                setTimeout(() => createBell(783.99, 1.5, 0.1), 200);
                setTimeout(() => createBell(1046.50, 2.0, 0.1), 300);
            }
        }

        const BOARD_SIZE = 8;
        const COLORS = ['c-cyan', 'c-pink', 'c-yellow', 'c-green'];
        const SHAPES = [
            [[1]], [[1,1]], [[1,1,1]], [[1,1,1,1]], 
            [[1],[1]], [[1],[1],[1]], [[1],[1],[1],[1]], 
            [[1,1],[1,1]], [[1,0],[1,1]], [[0,1],[1,1]], 
            [[1,1],[1,0]], [[1,1],[0,1]], [[1,1,1],[0,1,0]], 
            [[1,0,0],[1,1,1]], [[0,0,1],[1,1,1]]
        ];

        class RealBlck {
            constructor() {
                this.grid = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null));
                this.score = 0;
                this.highScore = localStorage.getItem('xmasblck_highscore') || 0;
                this.shapesInDock = [];
                this.dom = {
                    board: document.getElementById('game-board'),
                    dock: document.getElementById('shape-dock'),
                    score: document.getElementById('current-score'),
                    highScore: document.getElementById('high-score'),
                    proxy: document.getElementById('drag-proxy'),
                    modal: document.getElementById('game-over-modal'),
                    finalScore: document.getElementById('final-score')
                };
                this.init();
            }

            init() {
                this.dom.highScore.textContent = this.highScore;
                this.renderGrid();
                this.refillDock();
                window.addEventListener('resize', () => this.measureBoard());
                setTimeout(() => this.measureBoard(), 100); 
            }

            measureBoard() {
                const rect = this.dom.board.getBoundingClientRect();
                this.boardState = {
                    left: rect.left,
                    top: rect.top,
                    width: rect.width,
                    cellSize: (rect.width - 4 * 2) / BOARD_SIZE 
                };
                this.boardState.simpleCellSize = rect.width / BOARD_SIZE;
            }

            renderGrid() {
                this.dom.board.innerHTML = '';
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        if (this.grid[r][c]) cell.classList.add('filled', this.grid[r][c]);
                        this.dom.board.appendChild(cell);
                    }
                }
            }

            getShapeHTML(matrix, color, isProxy = false) {
                const cols = matrix[0].length;
                const cellClass = isProxy ? `mini-cell ${color}` : `mini-cell ${color}`;
                const gridStyle = isProxy ? `grid-template-columns: repeat(${cols}, 1fr); width: max-content;` : `grid-template-columns: repeat(${cols}, 22px);`;
                
                return `<div class="mini-grid" style="${gridStyle}">
                    ${matrix.flat().map(v => `<div class="${v ? cellClass : 'w-0 h-0 opacity-0'}"></div>`).join('')}
                </div>`;
            }

            refillDock() {
                this.dom.dock.innerHTML = '';
                this.shapesInDock = [];
                for (let i = 0; i < 3; i++) {
                    const shapeIdx = Math.floor(Math.random() * SHAPES.length);
                    const color = COLORS[Math.floor(Math.random() * COLORS.length)];
                    const matrix = SHAPES[shapeIdx];
                    
                    const el = document.createElement('div');
                    el.className = 'draggable-shape animate-pop';
                    el.innerHTML = this.getShapeHTML(matrix, color, false);
                    
                    this.shapesInDock.push({ matrix, color, el, used: false });
                    
                    const startHandler = (e) => this.startDrag(e, i);
                    el.addEventListener('mousedown', startHandler);
                    el.addEventListener('touchstart', startHandler, {passive: false});
                    
                    this.dom.dock.appendChild(el);
                }
                if (!this.canMakeMove()) setTimeout(() => this.gameOver(), 500);
            }

            startDrag(e, index) {
                e.preventDefault();
                const shapeData = this.shapesInDock[index];
                if (shapeData.used) return;

                this.measureBoard();
                playSound('pick');

                shapeData.el.classList.add('ghost-active');
                
                const proxyCellSize = this.boardState.simpleCellSize - 4; 
                const cols = shapeData.matrix[0].length;
                
                let proxyHtml = `<div class="mini-grid" style="grid-template-columns: repeat(${cols}, ${this.boardState.simpleCellSize}px); gap: 4px;">`;
                shapeData.matrix.flat().forEach(v => {
                    proxyHtml += `<div style="height:${this.boardState.simpleCellSize-4}px; border-radius:6px;" class="${v ? 'cell filled '+shapeData.color : 'opacity-0'}"></div>`;
                });
                proxyHtml += `</div>`;

                this.dom.proxy.innerHTML = proxyHtml;
                this.dom.proxy.style.display = 'block';

                const proxyWidth = cols * this.boardState.simpleCellSize;
                const proxyHeight = shapeData.matrix.length * this.boardState.simpleCellSize;

                this.dragState = {
                    data: shapeData,
                    width: proxyWidth,
                    height: proxyHeight,
                    offsetY: 100
                };

                this.updateDragPosition(e);

                const moveFn = (ev) => this.updateDragPosition(ev);
                const endFn = (ev) => {
                    document.removeEventListener('mousemove', moveFn);
                    document.removeEventListener('touchmove', moveFn);
                    document.removeEventListener('mouseup', endFn);
                    document.removeEventListener('touchend', endFn);
                    this.endDrag(ev);
                };

                document.addEventListener('mousemove', moveFn);
                document.addEventListener('touchmove', moveFn, {passive: false});
                document.addEventListener('mouseup', endFn);
                document.addEventListener('touchend', endFn);
            }

            updateDragPosition(e) {
                if (!this.dragState) return;
                e.preventDefault(); 

                const cx = e.touches ? e.touches[0].clientX : e.clientX;
                const cy = e.touches ? e.touches[0].clientY : e.clientY;

                const proxyLeft = cx - (this.dragState.width / 2);
                const proxyTop = cy - this.dragState.offsetY - (this.dragState.height / 2);

                this.dom.proxy.style.left = `${proxyLeft}px`;
                this.dom.proxy.style.top = `${proxyTop}px`;

                this.clearPreviews();
                
                const relativeX = proxyLeft - this.boardState.left + (this.boardState.simpleCellSize / 2); 
                const relativeY = proxyTop - this.boardState.top + (this.boardState.simpleCellSize / 2);

                const c = Math.floor(relativeX / this.boardState.simpleCellSize);
                const r = Math.floor(relativeY / this.boardState.simpleCellSize);

                if (this.canPlace(this.dragState.data.matrix, r, c)) {
                    this.showPreview(this.dragState.data.matrix, r, c, this.dragState.data.color);
                    this.dragState.target = {r, c};
                } else {
                    this.dragState.target = null;
                }
            }

            endDrag(e) {
                if (!this.dragState) return;

                this.dom.proxy.style.display = 'none';
                this.clearPreviews();
                
                if (this.dragState.target) {
                    this.placeShape(this.dragState.data.matrix, this.dragState.target.r, this.dragState.target.c, this.dragState.data.color);
                    this.dragState.data.el.style.visibility = 'hidden';
                    this.dragState.data.used = true;
                    playSound('place');
                    
                    this.checkLines();
                    
                    if (this.shapesInDock.every(s => s.used)) {
                        setTimeout(() => this.refillDock(), 200);
                    } else if (!this.canMakeMove()) {
                        setTimeout(() => this.gameOver(), 500);
                    }
                } else {
                    this.dragState.data.el.classList.remove('ghost-active');
                }
                
                this.dragState = null;
            }

            canPlace(matrix, r, c) {
                if (r < 0 || c < 0) return false;
                if (r + matrix.length > BOARD_SIZE) return false;
                if (c + matrix[0].length > BOARD_SIZE) return false;

                for (let i = 0; i < matrix.length; i++) {
                    for (let j = 0; j < matrix[0].length; j++) {
                        if (matrix[i][j] === 1) {
                            if (this.grid[r+i][c+j] !== null) return false;
                        }
                    }
                }
                return true;
            }

            showPreview(matrix, r, c, color) {
                for (let i = 0; i < matrix.length; i++) {
                    for (let j = 0; j < matrix[0].length; j++) {
                        if (matrix[i][j] === 1) {
                            const idx = (r+i)*BOARD_SIZE + (c+j);
                            if (this.dom.board.children[idx]) {
                                this.dom.board.children[idx].classList.add('preview', color);
                            }
                        }
                    }
                }
            }

            clearPreviews() {
                this.dom.board.querySelectorAll('.preview').forEach(el => {
                    el.classList.remove('preview', 'c-cyan', 'c-pink', 'c-yellow', 'c-green');
                });
            }

            placeShape(matrix, r, c, color) {
                let points = 0;
                for (let i = 0; i < matrix.length; i++) {
                    for (let j = 0; j < matrix[0].length; j++) {
                        if (matrix[i][j] === 1) {
                            this.grid[r+i][c+j] = color;
                            const el = this.dom.board.children[(r+i)*BOARD_SIZE + (c+j)];
                            el.className = `cell filled ${color} animate-pop`;
                            points++;
                        }
                    }
                }
                this.score += points;
                this.updateScore();
            }

            checkLines() {
                let rows = [], cols = [];
                for(let r=0; r<BOARD_SIZE; r++) if(this.grid[r].every(v => v)) rows.push(r);
                for(let c=0; c<BOARD_SIZE; c++) if(this.grid.every(row => row[c])) cols.push(c);

                if (rows.length === 0 && cols.length === 0) return;

                const cellsToClear = new Set();
                rows.forEach(r => {
                    for(let c=0; c<BOARD_SIZE; c++) cellsToClear.add(`${r},${c}`);
                });
                cols.forEach(c => {
                    for(let r=0; r<BOARD_SIZE; r++) cellsToClear.add(`${r},${c}`);
                });

                this.score += cellsToClear.size * 10 * (rows.length + cols.length);
                this.updateScore();
                playSound('clear');

                cellsToClear.forEach(key => {
                    const [r, c] = key.split(',').map(Number);
                    this.grid[r][c] = null;
                    const el = this.dom.board.children[r*BOARD_SIZE + c];
                    el.classList.add('animate-clear');
                    setTimeout(() => el.className = 'cell', 300);
                });
            }

            canMakeMove() {
                const available = this.shapesInDock.filter(s => !s.used);
                if (available.length === 0) return true;
                for (let s of available) {
                    for (let r = 0; r < BOARD_SIZE; r++) {
                        for (let c = 0; c < BOARD_SIZE; c++) {
                            if (this.canPlace(s.matrix, r, c)) return true;
                        }
                    }
                }
                return false;
            }

            updateScore() {
                this.dom.score.innerText = this.score;
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    this.dom.highScore.innerText = this.highScore;
                    localStorage.setItem('xmasblck_highscore', this.highScore);
                }
            }

            gameOver() {
                this.dom.finalScore.innerText = this.score;
                this.dom.modal.classList.remove('hidden');
                setTimeout(() => this.dom.modal.classList.remove('opacity-0'), 10);
            }

            restart() {
                this.dom.modal.classList.add('opacity-0');
                setTimeout(() => {
                    this.dom.modal.classList.add('hidden');
                    this.grid = this.grid.map(row => row.fill(null));
                    this.renderGrid();
                    this.score = 0;
                    this.updateScore();
                    this.refillDock();
                }, 300);
            }
        }

        const game = new RealBlck();
    </script>
</body>
</html>