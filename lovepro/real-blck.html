<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Real Blck</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Kanit:wght@300;400;600&family=Orbitron:wght@700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #0f172a;
            --grid-color: #1e293b;
            --accent-cyan: #06b6d4;
            --accent-pink: #ec4899;
            --accent-yellow: #eab308;
            --accent-green: #22c55e;
        }

        body {
            font-family: 'Kanit', sans-serif;
            background-color: var(--bg-color);
            background-image: radial-gradient(circle at 50% 50%, #1e293b 0%, #0f172a 100%);
            color: white;
            overflow: hidden;
            touch-action: none;
        }

        .brand-font {
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 2px;
        }

        /* --- Back Button Style --- */
        .back-button {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            color: #94a3b8;
            text-decoration: none;
            font-weight: 600;
            font-size: 14px;
            padding: 8px 16px;
            background: rgba(255,255,255,0.05);
            border-radius: 20px;
            backdrop-filter: blur(4px);
            transition: all 0.2s;
            z-index: 50;
        }
        .back-button:hover {
            background: rgba(255,255,255,0.15);
            color: white;
            transform: translateX(-2px);
        }

        /* Board Styling */
        .game-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 4px;
            padding: 4px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 12px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            aspect-ratio: 1;
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
            position: relative;
        }

        .cell {
            background: var(--grid-color);
            border-radius: 4px;
            transition: background-color 0.1s;
        }

        /* Color Classes */
        .c-cyan { background-color: var(--accent-cyan); box-shadow: 0 0 10px var(--accent-cyan); }
        .c-pink { background-color: var(--accent-pink); box-shadow: 0 0 10px var(--accent-pink); }
        .c-yellow { background-color: var(--accent-yellow); box-shadow: 0 0 10px var(--accent-yellow); }
        .c-green { background-color: var(--accent-green); box-shadow: 0 0 10px var(--accent-green); }
        
        .cell.preview {
            opacity: 0.4;
            transform: scale(0.95);
            box-shadow: inset 0 0 5px rgba(255,255,255,0.5);
        }

        /* Shape Container */
        .shape-dock {
            display: flex;
            justify-content: space-around;
            align-items: center;
            min-height: 130px;
            margin-top: 10px;
            padding: 10px;
            width: 100%;
        }

        .draggable-shape {
            touch-action: none;
            cursor: grab;
            transition: transform 0.1s, opacity 0.2s;
            padding: 10px;
        }

        .draggable-shape:active {
            cursor: grabbing;
            transform: scale(1.1);
        }

        .mini-grid {
            display: grid;
            gap: 2px;
            pointer-events: none;
        }

        .mini-cell {
            width: 22px;
            height: 22px;
            border-radius: 3px;
        }

        /* Drag Proxy */
        #drag-proxy {
            position: fixed;
            pointer-events: none;
            z-index: 100;
            display: none;
            opacity: 0.9;
            transform-origin: center center;
        }

        #drag-proxy .mini-cell {
            width: 40px;
            height: 40px;
            gap: 4px;
            box-shadow: 0 0 15px rgba(255,255,255,0.2);
        }
        
        #drag-proxy .mini-grid {
            gap: 4px;
        }

        /* Animations */
        @keyframes pop { 0% { transform: scale(0); } 70% { transform: scale(1.1); } 100% { transform: scale(1); } }
        @keyframes clear-flash { 0% { filter: brightness(1); transform: scale(1); } 50% { filter: brightness(2); transform: scale(1.1); } 100% { opacity: 0; transform: scale(0); } }

        .animate-pop { animation: pop 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        .animate-clear { animation: clear-flash 0.3s forwards; z-index: 10; }

        /* UI Helpers */
        .glass-panel {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
        }

        .ghost-active { opacity: 0.1; }
    </style>
</head>
<body class="h-screen w-full flex flex-col items-center justify-center p-4 select-none">

    <!-- Navigation Back Button -->
    <a href="index.html" class="back-button">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
            <path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/>
        </svg>
        BACK
    </a>

    <!-- Header -->
    <div class="w-full max-w-md flex justify-between items-end mb-4 mt-8">
        <div>
            <h1 class="text-3xl brand-font text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-pink-500" style="text-shadow: 0 0 20px rgba(6, 182, 212, 0.5);">REAL BLCK</h1>
        </div>
        <div class="text-right">
            <div class="text-xs text-slate-400">BEST</div>
            <div id="high-score" class="text-xl font-bold text-yellow-400 font-mono">0</div>
        </div>
    </div>

    <!-- Score Board -->
    <div class="glass-panel w-full max-w-md py-3 px-6 mb-4 flex justify-between items-center">
        <span class="text-slate-300 text-sm">SCORE</span>
        <span id="current-score" class="text-4xl font-bold text-white font-mono">0</span>
    </div>

    <!-- Game Area -->
    <div class="relative w-full max-w-md flex flex-col items-center">
        
        <!-- Grid -->
        <div id="game-board" class="game-board"></div>

        <!-- Dock -->
        <div id="shape-dock" class="shape-dock"></div>

    </div>

    <!-- Drag Proxy -->
    <div id="drag-proxy"></div>

    <!-- Game Over Modal -->
    <div id="game-over-modal" class="fixed inset-0 bg-black/90 z-50 flex items-center justify-center hidden opacity-0 transition-opacity duration-300">
        <div class="text-center p-8" id="modal-content">
            <h2 class="text-5xl brand-font text-pink-500 mb-4 drop-shadow-glow tracking-widest">GAME OVER</h2>
            <div class="text-2xl text-white font-mono mb-8" id="final-score">0</div>
            <button onclick="game.restart()" class="px-10 py-4 bg-white text-black font-bold text-xl rounded-full hover:scale-105 transition-transform brand-font">
                RETRY
            </button>
            <br><br>
            <a href="index.html" class="text-slate-400 hover:text-white underline text-sm mt-4">Return to Menu</a>
        </div>
    </div>

    <script>
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;

            if (type === 'pick') {
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(400, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'place') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(100, now);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'clear') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.linearRampToValueAtTime(600, now + 0.1);
                osc.frequency.linearRampToValueAtTime(900, now + 0.2);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
            }
        }

        const BOARD_SIZE = 8;
        const COLORS = ['c-cyan', 'c-pink', 'c-yellow', 'c-green'];
        const SHAPES = [
            [[1]], [[1,1]], [[1,1,1]], [[1,1,1,1]], 
            [[1],[1]], [[1],[1],[1]], [[1],[1],[1],[1]], 
            [[1,1],[1,1]], [[1,0],[1,1]], [[0,1],[1,1]], 
            [[1,1],[1,0]], [[1,1],[0,1]], [[1,1,1],[0,1,0]], 
            [[1,0,0],[1,1,1]], [[0,0,1],[1,1,1]]
        ];

        class RealBlck {
            constructor() {
                this.grid = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null));
                this.score = 0;
                this.highScore = localStorage.getItem('realblck_highscore') || 0;
                this.shapesInDock = [];
                this.dom = {
                    board: document.getElementById('game-board'),
                    dock: document.getElementById('shape-dock'),
                    score: document.getElementById('current-score'),
                    highScore: document.getElementById('high-score'),
                    proxy: document.getElementById('drag-proxy'),
                    modal: document.getElementById('game-over-modal'),
                    finalScore: document.getElementById('final-score')
                };
                this.init();
            }

            init() {
                this.dom.highScore.textContent = this.highScore;
                this.renderGrid();
                this.refillDock();
                window.addEventListener('resize', () => this.measureBoard());
                setTimeout(() => this.measureBoard(), 100); 
            }

            measureBoard() {
                const rect = this.dom.board.getBoundingClientRect();
                this.boardState = {
                    left: rect.left,
                    top: rect.top,
                    width: rect.width,
                    cellSize: (rect.width - 4 * 2) / BOARD_SIZE 
                };
                this.boardState.simpleCellSize = rect.width / BOARD_SIZE;
            }

            renderGrid() {
                this.dom.board.innerHTML = '';
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        if (this.grid[r][c]) cell.classList.add('filled', this.grid[r][c]);
                        this.dom.board.appendChild(cell);
                    }
                }
            }

            getShapeHTML(matrix, color, isProxy = false) {
                const cols = matrix[0].length;
                const cellClass = isProxy ? `mini-cell ${color}` : `mini-cell ${color}`;
                const gridStyle = isProxy ? `grid-template-columns: repeat(${cols}, 1fr); width: max-content;` : `grid-template-columns: repeat(${cols}, 22px);`;
                
                return `<div class="mini-grid" style="${gridStyle}">
                    ${matrix.flat().map(v => `<div class="${v ? cellClass : 'w-0 h-0 opacity-0'}"></div>`).join('')}
                </div>`;
            }

            refillDock() {
                this.dom.dock.innerHTML = '';
                this.shapesInDock = [];
                for (let i = 0; i < 3; i++) {
                    const shapeIdx = Math.floor(Math.random() * SHAPES.length);
                    const color = COLORS[Math.floor(Math.random() * COLORS.length)];
                    const matrix = SHAPES[shapeIdx];
                    
                    const el = document.createElement('div');
                    el.className = 'draggable-shape animate-pop';
                    el.innerHTML = this.getShapeHTML(matrix, color, false);
                    
                    this.shapesInDock.push({ matrix, color, el, used: false });
                    
                    const startHandler = (e) => this.startDrag(e, i);
                    el.addEventListener('mousedown', startHandler);
                    el.addEventListener('touchstart', startHandler, {passive: false});
                    
                    this.dom.dock.appendChild(el);
                }
                if (!this.canMakeMove()) setTimeout(() => this.gameOver(), 500);
            }

            startDrag(e, index) {
                e.preventDefault();
                const shapeData = this.shapesInDock[index];
                if (shapeData.used) return;

                this.measureBoard();
                playSound('pick');

                shapeData.el.classList.add('ghost-active');
                
                const proxyCellSize = this.boardState.simpleCellSize - 4; 
                const cols = shapeData.matrix[0].length;
                
                let proxyHtml = `<div class="mini-grid" style="grid-template-columns: repeat(${cols}, ${this.boardState.simpleCellSize}px); gap: 4px;">`;
                shapeData.matrix.flat().forEach(v => {
                    proxyHtml += `<div style="height:${this.boardState.simpleCellSize-4}px; border-radius:4px;" class="${v ? 'cell filled '+shapeData.color : 'opacity-0'}"></div>`;
                });
                proxyHtml += `</div>`;

                this.dom.proxy.innerHTML = proxyHtml;
                this.dom.proxy.style.display = 'block';

                const proxyWidth = cols * this.boardState.simpleCellSize;
                const proxyHeight = shapeData.matrix.length * this.boardState.simpleCellSize;

                this.dragState = {
                    data: shapeData,
                    width: proxyWidth,
                    height: proxyHeight,
                    offsetY: 100
                };

                this.updateDragPosition(e);

                const moveFn = (ev) => this.updateDragPosition(ev);
                const endFn = (ev) => {
                    document.removeEventListener('mousemove', moveFn);
                    document.removeEventListener('touchmove', moveFn);
                    document.removeEventListener('mouseup', endFn);
                    document.removeEventListener('touchend', endFn);
                    this.endDrag(ev);
                };

                document.addEventListener('mousemove', moveFn);
                document.addEventListener('touchmove', moveFn, {passive: false});
                document.addEventListener('mouseup', endFn);
                document.addEventListener('touchend', endFn);
            }

            updateDragPosition(e) {
                if (!this.dragState) return;
                e.preventDefault(); 

                const cx = e.touches ? e.touches[0].clientX : e.clientX;
                const cy = e.touches ? e.touches[0].clientY : e.clientY;

                const proxyLeft = cx - (this.dragState.width / 2);
                const proxyTop = cy - this.dragState.offsetY - (this.dragState.height / 2);

                this.dom.proxy.style.left = `${proxyLeft}px`;
                this.dom.proxy.style.top = `${proxyTop}px`;

                this.clearPreviews();
                
                const relativeX = proxyLeft - this.boardState.left + (this.boardState.simpleCellSize / 2); 
                const relativeY = proxyTop - this.boardState.top + (this.boardState.simpleCellSize / 2);

                const c = Math.floor(relativeX / this.boardState.simpleCellSize);
                const r = Math.floor(relativeY / this.boardState.simpleCellSize);

                if (this.canPlace(this.dragState.data.matrix, r, c)) {
                    this.showPreview(this.dragState.data.matrix, r, c, this.dragState.data.color);
                    this.dragState.target = {r, c};
                } else {
                    this.dragState.target = null;
                }
            }

            endDrag(e) {
                if (!this.dragState) return;

                this.dom.proxy.style.display = 'none';
                this.clearPreviews();
                
                if (this.dragState.target) {
                    this.placeShape(this.dragState.data.matrix, this.dragState.target.r, this.dragState.target.c, this.dragState.data.color);
                    this.dragState.data.el.style.visibility = 'hidden';
                    this.dragState.data.used = true;
                    playSound('place');
                    
                    this.checkLines();
                    
                    if (this.shapesInDock.every(s => s.used)) {
                        setTimeout(() => this.refillDock(), 200);
                    } else if (!this.canMakeMove()) {
                        setTimeout(() => this.gameOver(), 500);
                    }
                } else {
                    this.dragState.data.el.classList.remove('ghost-active');
                }
                
                this.dragState = null;
            }

            canPlace(matrix, r, c) {
                if (r < 0 || c < 0) return false;
                if (r + matrix.length > BOARD_SIZE) return false;
                if (c + matrix[0].length > BOARD_SIZE) return false;

                for (let i = 0; i < matrix.length; i++) {
                    for (let j = 0; j < matrix[0].length; j++) {
                        if (matrix[i][j] === 1) {
                            if (this.grid[r+i][c+j] !== null) return false;
                        }
                    }
                }
                return true;
            }

            showPreview(matrix, r, c, color) {
                for (let i = 0; i < matrix.length; i++) {
                    for (let j = 0; j < matrix[0].length; j++) {
                        if (matrix[i][j] === 1) {
                            const idx = (r+i)*BOARD_SIZE + (c+j);
                            if (this.dom.board.children[idx]) {
                                this.dom.board.children[idx].classList.add('preview', color);
                            }
                        }
                    }
                }
            }

            clearPreviews() {
                this.dom.board.querySelectorAll('.preview').forEach(el => {
                    el.classList.remove('preview', 'c-cyan', 'c-pink', 'c-yellow', 'c-green');
                });
            }

            placeShape(matrix, r, c, color) {
                let points = 0;
                for (let i = 0; i < matrix.length; i++) {
                    for (let j = 0; j < matrix[0].length; j++) {
                        if (matrix[i][j] === 1) {
                            this.grid[r+i][c+j] = color;
                            const el = this.dom.board.children[(r+i)*BOARD_SIZE + (c+j)];
                            el.className = `cell filled ${color} animate-pop`;
                            points++;
                        }
                    }
                }
                this.score += points;
                this.updateScore();
            }

            checkLines() {
                let rows = [], cols = [];
                for(let r=0; r<BOARD_SIZE; r++) if(this.grid[r].every(v => v)) rows.push(r);
                for(let c=0; c<BOARD_SIZE; c++) if(this.grid.every(row => row[c])) cols.push(c);

                if (rows.length === 0 && cols.length === 0) return;

                const cellsToClear = new Set();
                rows.forEach(r => {
                    for(let c=0; c<BOARD_SIZE; c++) cellsToClear.add(`${r},${c}`);
                });
                cols.forEach(c => {
                    for(let r=0; r<BOARD_SIZE; r++) cellsToClear.add(`${r},${c}`);
                });

                this.score += cellsToClear.size * 10 * (rows.length + cols.length);
                this.updateScore();
                playSound('clear');

                cellsToClear.forEach(key => {
                    const [r, c] = key.split(',').map(Number);
                    this.grid[r][c] = null;
                    const el = this.dom.board.children[r*BOARD_SIZE + c];
                    el.classList.add('animate-clear');
                    setTimeout(() => el.className = 'cell', 300);
                });
            }

            canMakeMove() {
                const available = this.shapesInDock.filter(s => !s.used);
                if (available.length === 0) return true;
                for (let s of available) {
                    for (let r = 0; r < BOARD_SIZE; r++) {
                        for (let c = 0; c < BOARD_SIZE; c++) {
                            if (this.canPlace(s.matrix, r, c)) return true;
                        }
                    }
                }
                return false;
            }

            updateScore() {
                this.dom.score.innerText = this.score;
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    this.dom.highScore.innerText = this.highScore;
                    localStorage.setItem('realblck_highscore', this.highScore);
                }
            }

            gameOver() {
                this.dom.finalScore.innerText = this.score;
                this.dom.modal.classList.remove('hidden');
                setTimeout(() => this.dom.modal.classList.remove('opacity-0'), 10);
            }

            restart() {
                this.dom.modal.classList.add('opacity-0');
                setTimeout(() => {
                    this.dom.modal.classList.add('hidden');
                    this.grid = this.grid.map(row => row.fill(null));
                    this.renderGrid();
                    this.score = 0;
                    this.updateScore();
                    this.refillDock();
                }, 300);
            }
        }

        const game = new RealBlck();
    </script>
</body>
</html>